//*
// Katib GRPC API v1beta1

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: api.proto

package api_v1_beta1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	DBManager_ReportObservationLog_FullMethodName = "/api.v1.beta1.DBManager/ReportObservationLog"
	DBManager_GetObservationLog_FullMethodName    = "/api.v1.beta1.DBManager/GetObservationLog"
	DBManager_DeleteObservationLog_FullMethodName = "/api.v1.beta1.DBManager/DeleteObservationLog"
)

// DBManagerClient is the client API for DBManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DBManagerClient interface {
	// *
	// Report a log of Observations for a Trial.
	// The log consists of timestamp and value of metric.
	// Katib store every log of metrics.
	// You can see accuracy curve or other metric logs on UI.
	ReportObservationLog(ctx context.Context, in *ReportObservationLogRequest, opts ...grpc.CallOption) (*ReportObservationLogReply, error)
	// *
	// Get all log of Observations for a Trial.
	GetObservationLog(ctx context.Context, in *GetObservationLogRequest, opts ...grpc.CallOption) (*GetObservationLogReply, error)
	// *
	// Delete all log of Observations for a Trial.
	DeleteObservationLog(ctx context.Context, in *DeleteObservationLogRequest, opts ...grpc.CallOption) (*DeleteObservationLogReply, error)
}

type dBManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewDBManagerClient(cc grpc.ClientConnInterface) DBManagerClient {
	return &dBManagerClient{cc}
}

func (c *dBManagerClient) ReportObservationLog(ctx context.Context, in *ReportObservationLogRequest, opts ...grpc.CallOption) (*ReportObservationLogReply, error) {
	out := new(ReportObservationLogReply)
	err := c.cc.Invoke(ctx, DBManager_ReportObservationLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dBManagerClient) GetObservationLog(ctx context.Context, in *GetObservationLogRequest, opts ...grpc.CallOption) (*GetObservationLogReply, error) {
	out := new(GetObservationLogReply)
	err := c.cc.Invoke(ctx, DBManager_GetObservationLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dBManagerClient) DeleteObservationLog(ctx context.Context, in *DeleteObservationLogRequest, opts ...grpc.CallOption) (*DeleteObservationLogReply, error) {
	out := new(DeleteObservationLogReply)
	err := c.cc.Invoke(ctx, DBManager_DeleteObservationLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DBManagerServer is the server API for DBManager service.
// All implementations should embed UnimplementedDBManagerServer
// for forward compatibility
type DBManagerServer interface {
	// *
	// Report a log of Observations for a Trial.
	// The log consists of timestamp and value of metric.
	// Katib store every log of metrics.
	// You can see accuracy curve or other metric logs on UI.
	ReportObservationLog(context.Context, *ReportObservationLogRequest) (*ReportObservationLogReply, error)
	// *
	// Get all log of Observations for a Trial.
	GetObservationLog(context.Context, *GetObservationLogRequest) (*GetObservationLogReply, error)
	// *
	// Delete all log of Observations for a Trial.
	DeleteObservationLog(context.Context, *DeleteObservationLogRequest) (*DeleteObservationLogReply, error)
}

// UnimplementedDBManagerServer should be embedded to have forward compatible implementations.
type UnimplementedDBManagerServer struct {
}

func (UnimplementedDBManagerServer) ReportObservationLog(context.Context, *ReportObservationLogRequest) (*ReportObservationLogReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportObservationLog not implemented")
}
func (UnimplementedDBManagerServer) GetObservationLog(context.Context, *GetObservationLogRequest) (*GetObservationLogReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetObservationLog not implemented")
}
func (UnimplementedDBManagerServer) DeleteObservationLog(context.Context, *DeleteObservationLogRequest) (*DeleteObservationLogReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteObservationLog not implemented")
}

// UnsafeDBManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DBManagerServer will
// result in compilation errors.
type UnsafeDBManagerServer interface {
	mustEmbedUnimplementedDBManagerServer()
}

func RegisterDBManagerServer(s grpc.ServiceRegistrar, srv DBManagerServer) {
	s.RegisterService(&DBManager_ServiceDesc, srv)
}

func _DBManager_ReportObservationLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportObservationLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DBManagerServer).ReportObservationLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DBManager_ReportObservationLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DBManagerServer).ReportObservationLog(ctx, req.(*ReportObservationLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DBManager_GetObservationLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetObservationLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DBManagerServer).GetObservationLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DBManager_GetObservationLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DBManagerServer).GetObservationLog(ctx, req.(*GetObservationLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DBManager_DeleteObservationLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteObservationLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DBManagerServer).DeleteObservationLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DBManager_DeleteObservationLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DBManagerServer).DeleteObservationLog(ctx, req.(*DeleteObservationLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DBManager_ServiceDesc is the grpc.ServiceDesc for DBManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DBManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v1.beta1.DBManager",
	HandlerType: (*DBManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportObservationLog",
			Handler:    _DBManager_ReportObservationLog_Handler,
		},
		{
			MethodName: "GetObservationLog",
			Handler:    _DBManager_GetObservationLog_Handler,
		},
		{
			MethodName: "DeleteObservationLog",
			Handler:    _DBManager_DeleteObservationLog_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

const (
	Suggestion_GetSuggestions_FullMethodName            = "/api.v1.beta1.Suggestion/GetSuggestions"
	Suggestion_ValidateAlgorithmSettings_FullMethodName = "/api.v1.beta1.Suggestion/ValidateAlgorithmSettings"
)

// SuggestionClient is the client API for Suggestion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SuggestionClient interface {
	GetSuggestions(ctx context.Context, in *GetSuggestionsRequest, opts ...grpc.CallOption) (*GetSuggestionsReply, error)
	ValidateAlgorithmSettings(ctx context.Context, in *ValidateAlgorithmSettingsRequest, opts ...grpc.CallOption) (*ValidateAlgorithmSettingsReply, error)
}

type suggestionClient struct {
	cc grpc.ClientConnInterface
}

func NewSuggestionClient(cc grpc.ClientConnInterface) SuggestionClient {
	return &suggestionClient{cc}
}

func (c *suggestionClient) GetSuggestions(ctx context.Context, in *GetSuggestionsRequest, opts ...grpc.CallOption) (*GetSuggestionsReply, error) {
	out := new(GetSuggestionsReply)
	err := c.cc.Invoke(ctx, Suggestion_GetSuggestions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *suggestionClient) ValidateAlgorithmSettings(ctx context.Context, in *ValidateAlgorithmSettingsRequest, opts ...grpc.CallOption) (*ValidateAlgorithmSettingsReply, error) {
	out := new(ValidateAlgorithmSettingsReply)
	err := c.cc.Invoke(ctx, Suggestion_ValidateAlgorithmSettings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SuggestionServer is the server API for Suggestion service.
// All implementations should embed UnimplementedSuggestionServer
// for forward compatibility
type SuggestionServer interface {
	GetSuggestions(context.Context, *GetSuggestionsRequest) (*GetSuggestionsReply, error)
	ValidateAlgorithmSettings(context.Context, *ValidateAlgorithmSettingsRequest) (*ValidateAlgorithmSettingsReply, error)
}

// UnimplementedSuggestionServer should be embedded to have forward compatible implementations.
type UnimplementedSuggestionServer struct {
}

func (UnimplementedSuggestionServer) GetSuggestions(context.Context, *GetSuggestionsRequest) (*GetSuggestionsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSuggestions not implemented")
}
func (UnimplementedSuggestionServer) ValidateAlgorithmSettings(context.Context, *ValidateAlgorithmSettingsRequest) (*ValidateAlgorithmSettingsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateAlgorithmSettings not implemented")
}

// UnsafeSuggestionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SuggestionServer will
// result in compilation errors.
type UnsafeSuggestionServer interface {
	mustEmbedUnimplementedSuggestionServer()
}

func RegisterSuggestionServer(s grpc.ServiceRegistrar, srv SuggestionServer) {
	s.RegisterService(&Suggestion_ServiceDesc, srv)
}

func _Suggestion_GetSuggestions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSuggestionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SuggestionServer).GetSuggestions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Suggestion_GetSuggestions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SuggestionServer).GetSuggestions(ctx, req.(*GetSuggestionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Suggestion_ValidateAlgorithmSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateAlgorithmSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SuggestionServer).ValidateAlgorithmSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Suggestion_ValidateAlgorithmSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SuggestionServer).ValidateAlgorithmSettings(ctx, req.(*ValidateAlgorithmSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Suggestion_ServiceDesc is the grpc.ServiceDesc for Suggestion service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Suggestion_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v1.beta1.Suggestion",
	HandlerType: (*SuggestionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSuggestions",
			Handler:    _Suggestion_GetSuggestions_Handler,
		},
		{
			MethodName: "ValidateAlgorithmSettings",
			Handler:    _Suggestion_ValidateAlgorithmSettings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

const (
	EarlyStopping_GetEarlyStoppingRules_FullMethodName         = "/api.v1.beta1.EarlyStopping/GetEarlyStoppingRules"
	EarlyStopping_SetTrialStatus_FullMethodName                = "/api.v1.beta1.EarlyStopping/SetTrialStatus"
	EarlyStopping_ValidateEarlyStoppingSettings_FullMethodName = "/api.v1.beta1.EarlyStopping/ValidateEarlyStoppingSettings"
)

// EarlyStoppingClient is the client API for EarlyStopping service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EarlyStoppingClient interface {
	GetEarlyStoppingRules(ctx context.Context, in *GetEarlyStoppingRulesRequest, opts ...grpc.CallOption) (*GetEarlyStoppingRulesReply, error)
	SetTrialStatus(ctx context.Context, in *SetTrialStatusRequest, opts ...grpc.CallOption) (*SetTrialStatusReply, error)
	ValidateEarlyStoppingSettings(ctx context.Context, in *ValidateEarlyStoppingSettingsRequest, opts ...grpc.CallOption) (*ValidateEarlyStoppingSettingsReply, error)
}

type earlyStoppingClient struct {
	cc grpc.ClientConnInterface
}

func NewEarlyStoppingClient(cc grpc.ClientConnInterface) EarlyStoppingClient {
	return &earlyStoppingClient{cc}
}

func (c *earlyStoppingClient) GetEarlyStoppingRules(ctx context.Context, in *GetEarlyStoppingRulesRequest, opts ...grpc.CallOption) (*GetEarlyStoppingRulesReply, error) {
	out := new(GetEarlyStoppingRulesReply)
	err := c.cc.Invoke(ctx, EarlyStopping_GetEarlyStoppingRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *earlyStoppingClient) SetTrialStatus(ctx context.Context, in *SetTrialStatusRequest, opts ...grpc.CallOption) (*SetTrialStatusReply, error) {
	out := new(SetTrialStatusReply)
	err := c.cc.Invoke(ctx, EarlyStopping_SetTrialStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *earlyStoppingClient) ValidateEarlyStoppingSettings(ctx context.Context, in *ValidateEarlyStoppingSettingsRequest, opts ...grpc.CallOption) (*ValidateEarlyStoppingSettingsReply, error) {
	out := new(ValidateEarlyStoppingSettingsReply)
	err := c.cc.Invoke(ctx, EarlyStopping_ValidateEarlyStoppingSettings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EarlyStoppingServer is the server API for EarlyStopping service.
// All implementations should embed UnimplementedEarlyStoppingServer
// for forward compatibility
type EarlyStoppingServer interface {
	GetEarlyStoppingRules(context.Context, *GetEarlyStoppingRulesRequest) (*GetEarlyStoppingRulesReply, error)
	SetTrialStatus(context.Context, *SetTrialStatusRequest) (*SetTrialStatusReply, error)
	ValidateEarlyStoppingSettings(context.Context, *ValidateEarlyStoppingSettingsRequest) (*ValidateEarlyStoppingSettingsReply, error)
}

// UnimplementedEarlyStoppingServer should be embedded to have forward compatible implementations.
type UnimplementedEarlyStoppingServer struct {
}

func (UnimplementedEarlyStoppingServer) GetEarlyStoppingRules(context.Context, *GetEarlyStoppingRulesRequest) (*GetEarlyStoppingRulesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEarlyStoppingRules not implemented")
}
func (UnimplementedEarlyStoppingServer) SetTrialStatus(context.Context, *SetTrialStatusRequest) (*SetTrialStatusReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTrialStatus not implemented")
}
func (UnimplementedEarlyStoppingServer) ValidateEarlyStoppingSettings(context.Context, *ValidateEarlyStoppingSettingsRequest) (*ValidateEarlyStoppingSettingsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateEarlyStoppingSettings not implemented")
}

// UnsafeEarlyStoppingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EarlyStoppingServer will
// result in compilation errors.
type UnsafeEarlyStoppingServer interface {
	mustEmbedUnimplementedEarlyStoppingServer()
}

func RegisterEarlyStoppingServer(s grpc.ServiceRegistrar, srv EarlyStoppingServer) {
	s.RegisterService(&EarlyStopping_ServiceDesc, srv)
}

func _EarlyStopping_GetEarlyStoppingRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEarlyStoppingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EarlyStoppingServer).GetEarlyStoppingRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EarlyStopping_GetEarlyStoppingRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EarlyStoppingServer).GetEarlyStoppingRules(ctx, req.(*GetEarlyStoppingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EarlyStopping_SetTrialStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTrialStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EarlyStoppingServer).SetTrialStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EarlyStopping_SetTrialStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EarlyStoppingServer).SetTrialStatus(ctx, req.(*SetTrialStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EarlyStopping_ValidateEarlyStoppingSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateEarlyStoppingSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EarlyStoppingServer).ValidateEarlyStoppingSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EarlyStopping_ValidateEarlyStoppingSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EarlyStoppingServer).ValidateEarlyStoppingSettings(ctx, req.(*ValidateEarlyStoppingSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EarlyStopping_ServiceDesc is the grpc.ServiceDesc for EarlyStopping service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EarlyStopping_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v1.beta1.EarlyStopping",
	HandlerType: (*EarlyStoppingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetEarlyStoppingRules",
			Handler:    _EarlyStopping_GetEarlyStoppingRules_Handler,
		},
		{
			MethodName: "SetTrialStatus",
			Handler:    _EarlyStopping_SetTrialStatus_Handler,
		},
		{
			MethodName: "ValidateEarlyStoppingSettings",
			Handler:    _EarlyStopping_ValidateEarlyStoppingSettings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}
